// TODO: Not sure if we actually want this.

syntax = "proto3";

package rayexec.ast.bound;

import "ast/raw.proto";
import "binder.proto";
import "logical.proto";
import "expr.proto";
import "schema.proto";

message Statement {
    oneof value {
        QueryNode query = 1;
    }
}

message QueryNode {
    optional CommonTableExprDefs ctes     = 1;
    QueryNodeBody                body     = 2;
    repeated OrderByNode         order_by = 3;
    optional LimitNode           limit    = 4;
}

message QueryNodeBody {
    oneof value {
        SelectNode select = 1;
        QueryNode  nested = 2;
        // TODO: set, values
    }
}

message CommonTableExprDefs {
    bool     recursive                     = 1;
    repeated binder.BoundCteReference ctes = 2;
}

message OrderByNode {
    Expr          expr       = 1;
    optional bool desc       = 2;
    optional bool nulls_last = 3;
}

message LimitNode {
    optional Expr limit  = 1;
    optional Expr offset = 2;
}

message SelectNode {
    optional DistinctModifier distinct    = 1;
    repeated SelectExpr       projections = 2;
    FromNode                  from        = 3;
    optional Expr             where_expr  = 4;
    optional GroupByNode      group_by    = 5;
    optional Expr             having      = 6;
}

message DistinctModifierOn {
    repeated Expr exprs = 1;
}

message GroupByExprs {
    repeated Expr exprs = 1;
}

message GroupByAll {}

message GroupByNode {
    oneof value {
        GroupByAll   all           = 1;
        GroupByExprs exprs         = 2;
        GroupByExprs cube          = 3;
        GroupByExprs rollup        = 4;
        GroupByExprs grouping_sets = 5;
    }
}

message DistinctModifierAll {}

message DistinctModifier {
    oneof value {
        DistinctModifierOn  on  = 1;
        DistinctModifierAll all = 2;
    }
}

message AliasedSelectExpr {
    ast.raw.Ident alias = 1;
    Expr          expr  = 2;
}

message QualifiedWildcardSelectExpr {
    ast.raw.ObjectReference reference = 1;
    SelectWildcard          wildcard  = 2;
}

message SelectReplaceColumn {
    ast.raw.Ident col  = 1;
    Expr          expr = 2;
}

message SelectWildcard {
    repeated ast.raw.Ident       exclude_cols = 1;
    repeated SelectReplaceColumn replace_cols = 2;
}

message SelectExpr {
    oneof value {
        Expr                        expr      = 1;
        AliasedSelectExpr           aliased   = 2;
        QualifiedWildcardSelectExpr qualified = 3;
        SelectWildcard              wildcard  = 4;
    }
}

message FromNode {
    optional FromAlias alias = 1;
    FromNodeBody       body  = 2;
}

message FromAlias {
    ast.raw.Ident alias            = 1;
    repeated ast.raw.Ident columns = 2;  // Optional, len(column) => None
}

message FromNodeBody {
    oneof value {
        FromBaseTable     base_table     = 1;
        FromFilePath      file           = 2;
        FromSubquery      subquery       = 3;
        FromTableFunction table_function = 4;
        FromJoin          join           = 5;
    }
}

message FromFilePath {
    string path = 1;
}

message FromBaseTable {
    binder.BindListIdx reference = 1;
}

message FromSubquery {
    QueryNode query = 1;
}

message FromTableFunction {
    binder.BindListIdx     reference = 1;
    expr.TableFunctionArgs args      = 2;
}

message FromJoin {
    FromNode         left           = 1;
    FromNode         right          = 2;
    ast.raw.JoinType join_type      = 3;
    JoinCondition    join_condition = 4;
}

message EmptyJoinCondition {}

message OnJoinCondition {
    Expr on = 1;
}

message UsingJoinCondition {
    repeated ast.raw.Ident idents = 1;
}

message JoinCondition {
    oneof value {
        OnJoinCondition on         = 1;
        UsingJoinCondition using   = 2;
        EmptyJoinCondition natural = 3;
        EmptyJoinCondition none    = 4;
    }
}

message CompoundIdentExpr {
    repeated ast.raw.Ident idents = 1;
}

message QualifiedWildcardExpr {
    repeated ast.raw.Ident idents = 1;
}

message LiteralExpr {
    Literal literal = 1;
}

message ArrayExpr {
    repeated Expr exprs = 1;
}

message ArraySubscriptSlice {
    optional Expr lower  = 1;
    optional Expr upper  = 2;
    optional Expr stride = 3;
}

message ArraySubscript {
    oneof value {
        Expr                index = 1;
        ArraySubscriptSlice slice = 2;
    }
}

message ArraySubscriptExpr {
    Expr           expr      = 1;
    ArraySubscript subscript = 2;
}

message UnaryExpr {
    logical.UnaryOperator op   = 1;
    Expr                  expr = 2;
}

message BinaryExpr {
    Expr                   left  = 1;
    logical.BinaryOperator op    = 2;
    Expr                   right = 3;
}

message FunctionArgExprWildcard {}

message FunctionArgExpr {
    oneof value {
        FunctionArgExprWildcard wildcard = 1;
        Expr                    expr     = 2;
    }
}

message FunctionArgNamed {
    ast.raw.Ident   name = 1;
    FunctionArgExpr arg  = 2;
}

message FunctionArgUnnamed {
    FunctionArgExpr arg = 1;
}

message FunctionArg {
    oneof value {
        FunctionArgNamed   named   = 1;
        FunctionArgUnnamed unnamed = 2;
    }
}

message FunctionExpr {
    binder.BindListIdx   idx    = 1;
    repeated FunctionArg args   = 2;
    optional Expr        filter = 3;
}

message TupleExpr {
    repeated Expr exprs = 1;
}

message CollateExpr {
    Expr                    expr      = 1;
    ast.raw.ObjectReference collation = 2;
}

message ExistsExpr {
    QueryNode subquery   = 1;
    bool      not_exists = 2;
}

message TypeStringExpr {
    schema.DataType datatype = 1;
    string          value    = 2;
}

message CastExpr {
    schema.DataType datatype = 1;
    Expr            expr     = 2;
}

message LikeExpr {
    Expr expr             = 1;
    Expr pattern          = 2;
    bool not_like         = 3;
    bool case_insensitive = 4;
}

message IntervalExpr {
    Expr     val                           = 1;
    optional ast.raw.IntervalUnit leading  = 2;
    optional ast.raw.IntervalUnit trailing = 3;
}

message Expr {
    oneof value {
        ast.raw.Ident         ident        = 1;
        CompoundIdentExpr     combound     = 2;
        QualifiedWildcardExpr qualified    = 3;
        LiteralExpr           literal      = 4;
        ArrayExpr             array        = 5;
        ArraySubscriptExpr    subscript    = 6;
        UnaryExpr             unary        = 7;
        BinaryExpr            binary       = 8;
        FunctionExpr          function     = 9;
        QueryNode             subquery     = 10;
        Expr                  nested       = 11;
        TupleExpr             tuple        = 12;
        CollateExpr           collate      = 13;
        ExistsExpr            exists       = 14;
        TypeStringExpr        typed_string = 15;
        CastExpr              cast         = 16;
        LikeExpr              like         = 17;
        IntervalExpr          interval     = 18;
    }
}

message LiteralStruct {
    repeated string keys   = 1;
    repeated Expr   values = 2;
}

message EmptyLiteral {}

message Literal {
    oneof value {
        string       number               = 1;
        string       single_quoted_string = 2;
        bool         boolean              = 3;
        EmptyLiteral null                 = 4;
        LiteralStruct struct              = 5;
    }
}
