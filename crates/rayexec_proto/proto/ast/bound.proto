syntax = "proto3";

package rayexec.ast.bound;

import "ast/raw.proto";
import "binder.proto";
import "expr.proto";
import "schema.proto";

message Statement {
    oneof value {
        QueryNode query = 1;
    }
}

message QueryNode {
    optional CommonTableExprDefs ctes     = 1;
    QueryNodeBody                body     = 2;
    repeated OrderByNode         order_by = 3;
    optional LimitNode           limit    = 4;
}

message QueryNodeBody {
    oneof value {
        SelectNode select = 1;
        QueryNode  nested = 2;
        // TODO: set, values
    }
}

message CommonTableExprDefs {
    bool     recursive                     = 1;
    repeated binder.BoundCteReference ctes = 2;
}

message OrderByNode {
    Expr          expr       = 1;
    optional bool desc       = 2;
    optional bool nulls_last = 3;
}

message LimitNode {
    optional Expr limit  = 1;
    optional Expr offset = 2;
}

message SelectNode {
    optional DistinctModifier distinct    = 1;
    repeated SelectExpr       projections = 2;
    FromNode                  from        = 3;
    optional Expr             where_expr  = 4;
    optional GroupByNode      group_by    = 5;
    optional Expr             having      = 6;
}

message DistinctModifierOn {
    repeated Expr exprs = 1;
}

message GroupByExprs {
    repeated Expr exprs = 1;
}

message GroupByAll {}

message GroupByNode {
    oneof value {
        GroupByAll   all           = 1;
        GroupByExprs exprs         = 2;
        GroupByExprs cube          = 3;
        GroupByExprs rollup        = 4;
        GroupByExprs grouping_sets = 5;
    }
}

message DistinctModifierAll {}

message DistinctModifier {
    oneof value {
        DistinctModifierOn  on  = 1;
        DistinctModifierAll all = 2;
    }
}

message AliasedSelectExpr {
    ast.raw.Ident alias = 1;
    Expr          expr  = 2;
}

message QualifiedWildcardSelectExpr {
    ast.raw.ObjectReference reference = 1;
    SelectWildcard          wildcard  = 2;
}

message SelectReplaceColumn {
    ast.raw.Ident col  = 1;
    Expr          expr = 2;
}

message SelectWildcard {
    repeated ast.raw.Ident       exclude_cols = 1;
    repeated SelectReplaceColumn replace_cols = 2;
}

message SelectExpr {
    oneof value {
        Expr                        expr      = 1;
        AliasedSelectExpr           aliased   = 2;
        QualifiedWildcardSelectExpr qualified = 3;
        SelectWildcard              wildcard  = 4;
    }
}

message FromNode {
    optional FromAlias alias = 1;
    FromNodeBody       body  = 2;
}

message FromAlias {
    ast.raw.Ident alias            = 1;
    repeated ast.raw.Ident columns = 2;  // Optional, len(column) => None
}

message FromNodeBody {
    oneof value {
        FromBaseTable     base_table     = 1;
        FromFilePath      file           = 2;
        FromSubquery      subquery       = 3;
        FromTableFunction table_function = 4;
        FromJoin          join           = 5;
    }
}

message FromFilePath {
    string path = 1;
}

message FromBaseTable {
    binder.BindListIdx reference = 1;
}

message FromSubquery {
    QueryNode query = 1;
}

message FromTableFunction {
    binder.BindListIdx     reference = 1;
    expr.TableFunctionArgs args      = 2;
}

message FromJoin {
    FromNode      left           = 1;
    FromNode      right          = 2;
    JoinType      join_type      = 3;
    JoinCondition join_condition = 4;
}

enum JoinType {
    INVALID_JOIN_TYPE = 0;
    CROSS             = 1;
    INNER             = 2;
    LEFT              = 3;
    RIGHT             = 4;
    OUTER             = 5;
    LEFT_ANTI         = 6;
    LEFT_SEMI         = 7;
    RIGHT_ANTI        = 8;
    RIGHT_SEMI        = 9;
}

message EmptyJoinCondition {}

message OnJoinCondition {
    Expr on = 1;
}

message UsingJoinCondition {
    repeated ast.raw.Ident idents = 1;
}

message JoinCondition {
    oneof value {
        OnJoinCondition on         = 1;
        UsingJoinCondition using   = 2;
        EmptyJoinCondition natural = 3;
        EmptyJoinCondition none    = 4;
    }
}

enum UnaryOperator {
    INVALID_UNARY_OPERATOR = 0;
    UNARY_PLUS             = 1;
    UNARY_MINUS            = 2;
    UNARY_NOT              = 3;
}

enum BinaryOperator {
    INVALID_BINARY_OPERATOR   = 0;
    BINARY_PLUS               = 1;
    BINARY_MINUS              = 2;
    BINARY_MULTIPLY           = 3;
    BINARY_DIVIDE             = 4;
    BINARY_INTDIV             = 5;
    BINARY_MODULO             = 6;
    BINARY_STRING_CONCAT      = 7;
    BINARY_STRING_STARTS_WITH = 8;
    BINARY_GT                 = 9;
    BINARY_LT                 = 10;
    BINARY_GTEQ               = 11;
    BINARY_LTEQ               = 12;
    BINARY_SPACESHIP          = 13;
    BINARY_EQ                 = 14;
    BINARY_NOTEQ              = 15;
    BINARY_AND                = 16;
    BINARY_OR                 = 17;
    BINARY_XOR                = 18;
    BINARY_BITWISE_OR         = 19;
    BINARY_BITWISE_AND        = 20;
    BINARY_BITWISE_XOR        = 21;
}

message CompoundIdentExpr {
    repeated ast.raw.Ident idents = 1;
}

message QualifiedWildcardExpr {
    repeated ast.raw.Ident idents = 1;
}

message LiteralExpr {
    Literal literal = 1;
}

message ArrayExpr {
    repeated Expr exprs = 1;
}

message ArraySubscriptSlice {
    optional Expr lower  = 1;
    optional Expr upper  = 2;
    optional Expr stride = 3;
}

message ArraySubscript {
    oneof value {
        Expr                index = 1;
        ArraySubscriptSlice slice = 2;
    }
}

message ArraySubscriptExpr {
    Expr           expr      = 1;
    ArraySubscript subscript = 2;
}

message UnaryExpr {
    UnaryOperator op   = 1;
    Expr          expr = 2;
}

message BinaryExpr {
    Expr           left  = 1;
    BinaryOperator op    = 2;
    Expr           right = 3;
}

message FunctionArgExprWildcard {}

message FunctionArgExpr {
    oneof value {
        FunctionArgExprWildcard wildcard = 1;
        Expr                    expr     = 2;
    }
}

message FunctionArgNamed {
    ast.raw.Ident   name = 1;
    FunctionArgExpr arg  = 2;
}

message FunctionArgUnnamed {
    FunctionArgExpr arg = 1;
}

message FunctionArg {
    oneof value {
        FunctionArgNamed   named   = 1;
        FunctionArgUnnamed unnamed = 2;
    }
}

message FunctionExpr {
    binder.BindListIdx   idx    = 1;
    repeated FunctionArg args   = 2;
    optional Expr        filter = 3;
}

message TupleExpr {
    repeated Expr exprs = 1;
}

message CollateExpr {
    Expr                    expr      = 1;
    ast.raw.ObjectReference collation = 2;
}

message ExistsExpr {
    QueryNode subquery   = 1;
    bool      not_exists = 2;
}

message TypeStringExpr {
    schema.DataType datatype = 1;
    string          value    = 2;
}

message CastExpr {
    schema.DataType datatype = 1;
    Expr            expr     = 2;
}

message LikeExpr {
    Expr expr             = 1;
    Expr pattern          = 2;
    bool not_like         = 3;
    bool case_insensitive = 4;
}

enum IntervalUnit {
    INVALID_INTERVAL_UNIT = 0;
    INTERVAL_MILLENIUM    = 1;
    INTERVAL_CENTURY      = 2;
    INTERVAL_DECADE       = 3;
    INTERVAL_YEAR         = 4;
    INTERVAL_MONTH        = 5;
    INTERVAL_WEEK         = 6;
    INTERVAL_DAY          = 7;
    INTERVAL_HOUR         = 8;
    INTERVAL_MINUTE       = 9;
    INTERVAL_SECOND       = 10;
    INTERVAL_MILLISECOND  = 11;
    INTERVAL_MICROSECOND  = 12;
    INTERVAL_NANOSECOND   = 13;
}

message IntervalExpr {
    Expr                  val      = 1;
    optional IntervalUnit leading  = 2;
    optional IntervalUnit trailing = 3;
}

message Expr {
    oneof value {
        ast.raw.Ident         ident        = 1;
        CompoundIdentExpr     combound     = 2;
        QualifiedWildcardExpr qualified    = 3;
        LiteralExpr           literal      = 4;
        ArrayExpr             array        = 5;
        ArraySubscriptExpr    subscript    = 6;
        UnaryExpr             unary        = 7;
        BinaryExpr            binary       = 8;
        FunctionExpr          function     = 9;
        QueryNode             subquery     = 10;
        Expr                  nested       = 11;
        TupleExpr             tuple        = 12;
        CollateExpr           collate      = 13;
        ExistsExpr            exists       = 14;
        TypeStringExpr        typed_string = 15;
        CastExpr              cast         = 16;
        LikeExpr              like         = 17;
        IntervalExpr          interval     = 18;
    }
}

message LiteralStruct {
    repeated string keys   = 1;
    repeated Expr   values = 2;
}

message EmptyLiteral {}

message Literal {
    oneof value {
        string       number               = 1;
        string       single_quoted_string = 2;
        bool         boolean              = 3;
        EmptyLiteral null                 = 4;
        LiteralStruct struct              = 5;
    }
}
