syntax = "proto3";

package rayexec.execution;

import "schema.proto";
import "expr.proto";
import "array.proto";

message TableEntry {
    string   name                 = 1;
    repeated schema.Field columns = 2;
}

enum OnConflict {
    INVALID_ON_CONFLICT = 0;
    IGNORE              = 1;
    REPLACE             = 2;
    ERROR               = 3;
}

message CreateTableInfo {
    string   name                     = 1;
    repeated schema.Field columns     = 2;
    OnConflict            on_conflict = 3;
}

message CreateSchemaInfo {
    string     name        = 1;
    OnConflict on_conflict = 2;
}

message EmptyDropObject {}

message DropObject {
    oneof value {
        string          index    = 1;
        string          function = 2;
        string          table    = 3;
        string          view     = 4;
        EmptyDropObject schema   = 5; // Schema name already contained in drop info.
    }
}

message DropInfo {
    string     catalog   = 1;
    string     schema    = 2;
    DropObject object    = 3;
    bool       cascade   = 4;
    bool       if_exists = 5;
}

message PhysicalCreateSchema {
    string           catalog = 1;
    CreateSchemaInfo info    = 2;
}

message PhysicalCreateTable {
    string          catalog = 1;
    string          schema  = 2;
    CreateTableInfo info    = 3;
    bool            is_ctas = 4;
}

message PhysicalDrop {
    DropInfo info = 1;
}

message PhysicalEmpty {}

message PhysicalFilter {
    expr.PhysicalScalarExpression predicate = 1;
}

message PhysicalProject {
    repeated expr.PhysicalScalarExpression exprs = 1;
}

message PhysicalInsert {
    string     catalog = 1;
    string     schema  = 2;
    TableEntry table   = 3;
}

message PhysicalLimit {
    uint64          limit  = 1;
    optional uint64 offset = 2;
}

message PhysicalMaterialize {
    uint64 num_outputs = 1;
}

message PhysicalScan {
    string     catalog = 1;
    string     schema  = 2;
    TableEntry table   = 3;
}

message PhysicalUngroupedAggregate {
    repeated expr.PhysicalAggregateExpression aggregates = 1;
}

message PhysicalUnion {}

message PhysicalValues {
    array.IpcStreamBatch batches = 1;
}

message PhysicalOperator {
    oneof value {
        PhysicalCreateSchema       create_schema       = 1;
        PhysicalCreateTable        create_table        = 2;
        PhysicalDrop               drop                = 3;
        PhysicalEmpty              empty               = 4;
        PhysicalFilter             filter              = 5;
        PhysicalProject            project             = 6;
        PhysicalInsert             insert              = 7;
        PhysicalLimit              limit               = 8;
        PhysicalMaterialize        materialize         = 9;
        PhysicalScan               scan                = 10;
        PhysicalUngroupedAggregate ungrouped_aggregate = 11;
        PhysicalUnion union                            = 12;
        PhysicalValues values                          = 13;
    }
}
